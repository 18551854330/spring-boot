<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1"
         metadata-complete="true">

    <display-name>Spring MVC Application</display-name>

    <!--配置 Spring 配置文件,启动业务层的 Spring 容器-
      web.xml中classpath:和classpath*:  有什么区别?
      classpath：只会到你的class路径中查找找文件;
      classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找.
    -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            <!--
              classpath:/applicationContext.xml, classpath:/applicationContext-tasks.xml
          -->
            classpath*:/applicationContext.xml
        </param-value>
    </context-param>

    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>


    <!-- spring Web MVC 框架提供了 org.springframework.web.filter.CharacterEncodingFilter
         用于解决POST方式造成的中文乱码问题，具体配置如下,以后我们项目及所有页面的编码均为 UTF-8
         -->
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>


    <!-- 防止 JPA 延迟加载，必须在调用类中使用事务，才可以防止延迟加载
         放在 spring-mvc 上面, filter 按照从下到上的顺序执行

         调用类必须使用事务标签 @Transactional ,才可以加载延迟加载的对象

         关于 LAZY 对象的展开：
         LAZY 对象的加载，一定要在调用层（即 java 代码中）按照需要加载，不要到 jsp 层自动加载。
         按照需要加载：对于实体类 Entity ，根据 jsp 中显示的需要，只调用需要的属性，不需要的属性不调用，没有被调用到的属性默认为 null。此种实体返回到 jsp，由于不调用为 null 的属性，所以不会影响程序正常运行。
         返回 jsp view 层的实体重新包装： 重新包装 Entity ，按照需要填充该 Entity的属性，返回到 view 层。

         在 java 代码中调用：
         被 LAZY 的对象有很多属性，有的属性还是集合形式的 LAZY 对象。
         只有在 java 代码中加载 LAZY 对象，才会去真正查询该对象，并且只会加载一层，即调用被 LAZY 的对象的普通属性，而不会更进一步去加载被 LAZY 的对象中的 LAZY 的对象。
         即在 java 代码中调用，才具有真正的 LAZY 作用，只有被调用了，才会去查询。

         在 jsp 页面中调用：
         此种方法不受代码控制，jsp 容器会把所有的 LAZY 都加载(即实体中所有的 LAZY 都会自动加载)，此时 LAZY 对象中还有 LAZY 对象，会逐级加载，如果遇到集合的属性，会产生大量的查询。
         尤其是对于用递归形式实现的树状结构，由于根节点为 null ，jsp 层加载，会反复查询，形成死循环。（调试了多日，得出的结论）

        -->


    <filter>
        <filter-name>Spring JPA OpenEntityManagerInViewFilter</filter-name>
        <filter-class>org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter</filter-class>
        <init-param>
            <!--
            指定 org.springframework.orm.jpa.LocalEntityManagerFactoryBean 在 spring 配置文件中的名称,默认值为 entityManagerFactory
            LocalEntityManagerFactoryBean 在 spring 中的名称不是 entityManagerFactory, 该参数一定要指定,否则会出现找不到 entityManagerFactory 的例外
            -->
            <param-name>entityManagerFactoryBeanName</param-name>
            <param-value>entityManagerFactoryMySQL</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>Spring JPA OpenEntityManagerInViewFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- sitemesh -->
    <filter>
        <filter-name>sitemeshFilter</filter-name>
        <filter-class>com.opensymphony.sitemesh.webapp.SiteMeshFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>sitemeshFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- 配置 Spring MVC 配置文件  spring-*.xml ，并指定其位置 -->
    <!--如果不配置init-param参数，则自动加载 WEB-INF/spring-mvc-servlet.xml 的spring配置文件，启动 web 层的 Spring 容器-->
    <!--xml 命名规范  <servlet-Name>-servlet.xml  -->
    <servlet>
        <servlet-name>spring-mvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-*.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring-mvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    <session-config>
        <session-timeout>120</session-timeout>
    </session-config>

    <welcome-file-list>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>

    <error-page>
        <exception-type>java.lang.Throwable</exception-type>
        <location>/WEB-INF/jsp/error/500.jsp</location>
    </error-page>

    <error-page>
        <error-code>500</error-code>
        <location>/WEB-INF/jsp/error/500.jsp</location>
    </error-page>
    <error-page>
        <error-code>404</error-code>
        <location>/WEB-INF/jsp/error/404.jsp</location>
    </error-page>

</web-app>
